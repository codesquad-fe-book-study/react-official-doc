## \***\*Conditional Rendering\*\***

### \***\*`null`을 사용해 조건부로 아무것도 반환하지 않기**

- 컴포넌트에서 `null`을 반환하는 것은 렌더링하려는 개발자를 놀라게 할 수 있기 때문에 일반적이지 않다. 부모 컴포넌트의 JSX에 컴포넌트를 조건부로 포함하거나 제외하는 경우가 더 많다.

### **Logical AND operator (`&&`)**

- Pitfall
  - `&&`의 왼쪽에 숫자를 넣지 마라.
  - `!!messageCount && <p>New messages</p>`

## Rendering Lists

### **Why does React need keys?**

- key를 사용하면 형제 항목 사이에서 특정 항목을 고유하게 식별할 수 있다.
- 잘 선택한 key는 배열 내 위치보다 더 많은 정보를 제공한다.
- Pitfall
  - 인덱스를 key로 사용하면 종종 미묘하고 혼란스러운 버그가 발생한다.
  - `key={Math.random()}`과 같이 즉석에서 key를 생성하지 말아야한다. 이렇게 하면 렌더링될 때마다 key가 일치하지 않아 매번 모든 컴포넌트와 DOM이 다시 생성된다.
  - 컴포넌트는 `key`를 prop으로 받지 않는다.

## \***\*Keeping Components Pure\*\***

### **Purity: Components as formulas**

- **자신의 일에만 신경쓴다.** 호출되기 전에 존재했던 객체나 변수를 변경하지 않는다.
- **동일 입력, 동일 출력.** 동일한 입력이 주어지면 항상 동일한 결과를 반환해야 한다.

### \***\*StrictMode로 순수하지 않은 계산 감지하기\*\***

- React에서는 렌더링하는 동안 읽을 수 있는 입력이 세 가지 있다.
  - [props](https://react-ko.dev/learn/passing-props-to-a-component), [state](https://react-ko.dev/learn/state-a-components-memory), [context](https://react-ko.dev/learn/passing-data-deeply-with-context). 이러한 입력은 항상 읽기 전용으로 취급해야 한다.
- 사용자 입력에 대한 응답으로 무언가를 변경하려면 변수에 쓰는 대신 [state](https://react-ko.dev/learn/state-a-components-memory)를 설정해야 한다.
  - 컴포넌트가 렌더링되는 동안에는 기존 변수나 객체를 절대 변경해서는 안 된다.

### **Where you *can* cause side effects**

- 화면 업데이트, 애니메이션 시작, 데이터 변경과 같은 이러한 변경을 **사이드 이펙트**라고 하며, 렌더링 중에 일어나는 것이 아니라 _“부수적으로”_ 일어나는 일이다.
- React에서 **사이드 이펙트는 보통 [이벤트 핸들러](https://react-ko.dev/learn/responding-to-events)에 속한다**.
  - 이벤트 핸들러는 사용자가 어떤 동작을 수행할 때(예를 들어, 버튼을 클릭할 때) React가 실행하는 함수이다.
  - 이벤트 핸들러가 컴포넌트 _내부에_ 정의되어 있긴 하지만 렌더링 중에는 실행되지 않는다.
  - **따라서 이벤트 핸들러는 순수할 필요가 없다.**
- 컴포넌트에서 `[useEffect](https://react-ko.dev/reference/react/useEffect)` 호출을 통해 반환된 JSX에 이벤트 핸들러를 첨부할 수 있다.
  - **하지만 이 방법은 최후의 수단으로 사용해야 한다.**

### **Why does React care about purity?**

- 입력이 변경되지 않은 컴포넌트는 [렌더링 건너뛰기](https://react-ko.dev/reference/react/memo)를 통해 성능을 향상시킬 수 있다.
  - 순수 함수는 항상 동일한 결과를 반환하므로 캐싱해도 안전하다.

# \***\*Adding Interactivity\*\***

## \***\*Responding to Events\*\***

### **Adding event handlers**

- onClick={handleClick}
- onMouseEnter={handleMouseEnter}

### **Naming event handler props**

- 관례상 이벤트 핸들러 props은 `on`으로 시작하고 그 뒤에 대문자가 와야한다.
  - `Button` 컴포넌트의 `onClick` prop은 `onSmash`로 호출할 수 있다.

## **State: A Component's Memory**

## **State as a Snapshot**

### **Setting state triggers renders**

- 버튼을 클릭하면 생기는 일
  - `onSubmit` 이벤트 핸들러가 실행된다.
  - `setIsSent(true)`가 `isSent`를 `true`로 설정하고 새 렌더링을 큐에 대기시킨다.
  - React는 새로운 `isSent` 값에 따라 컴포넌트를 다시 렌더링한다.

### \***\*Rendering takes a snapshot in time\*\***

- 렌더링이란 React가 컴포넌트, 즉 함수를 호출한다는 뜻이다.
  - 해당 함수에서 반환하는 JSX는 시간상 UI 스냅샷과 같다.
  - props, 이벤트 핸들러, 로컬 변수는 모두 렌더링 당시의 state를 사용해 계산된다.
- React가 컴포넌트를 다시 렌더링 할 때
  - React가 함수를 다시 호출한다.
  - 함수가 새로운 JSX 스냅샷을 반환한다.
  - Uadating DOM tree: 그러면 React가 반환한 스냅샷과 일치하도록 화면을 업데이트한다.
- State는 실제로 함수 외부에 마치 선반이 있는 것처럼 React 자체에 존재한다.
- React가 컴포넌트를 호출하면 특정 렌더링에 대한 state의 스냅샷을 제공한다.
  - React에게 state를 업데이트하도록 명령
  - React가 state 값을 업데이트
  - React가 state 값의 스냅샷을 컴포넌트에 보냄
- state를 설정하면 다음 렌더링에 대해서만 변경된다.
  ```jsx
  <button
    onClick={() => {
      setNumber(number + 1)
      setNumber(number + 1)
      setNumber(number + 1)
    }}
  >
    +3
  </button>
  ```
  - 첫 번째 렌더링에서 `number`는 0이었기 때문에 해당 렌더링의 `onClick`이 호출된 후에도 `number`의 값은 여전히 0이다.
  - `setNumber(number + 1)`: `number` is `0` so `setNumber(0 + 1)` : 이 버튼의 클릭 핸들러가 React에게 지시하는 작업

## **Queueing a Series of State Updates**

- state 변수를 설정하면 다음 렌더링이 큐(대기열, queue)에 들어간다.

### \***\*React batches state updates\*\***

- React는 state 업데이트를 하기 전에 이벤트 핸들러의 모든 코드가 실행될 때까지 기다린다.
  - 이 때문에 리렌더링은 모든 `setNumber()` 호출이 완료된 이후에만 일어난다.
  - 일괄처리(배칭, batching)라고도 하는 이 동작은 React 앱을 훨씬 빠르게 실행할 수 있게 해준다.

### \***\*Updating the same state multiple times before the next render\*\***

```jsx
<button
  onClick={() => {
    setNumber(n => n + 1)
    setNumber(n => n + 1)
    setNumber(n => n + 1)
  }}
>
  +3
</button>
```

- 단순히 state 값을 대체하는 것이 아니라 React에게 “state 값으로 무언가를 하라”고 지시하는 방법이다.
  - `setNumber(n => n + 1)`: `n => n + 1` 함수를 큐에 추가
    <img width="367" alt="image" src="https://user-images.githubusercontent.com/88878874/243516449-19b47841-045c-4afd-be21-21e48940b372.png">

## \***\*Updating Objects in State\*\***

### \***\*Copying objects with the spread syntax\*\***

- 큰 양식의 경우 올바르게 업데이트하기만 하면 모든 데이터를 객체에 그룹화하여 보관하는 것이 매우 편리하다.

```jsx
const [person, setPerson] = useState({
  firstName: 'Barbara',
  lastName: 'Hepworth',
  email: 'bhepworth@sculpture.com'
})

setPerson({
  ...person,
  firstName: e.target.value
})
```

### \***\*React에서 state 변이를 권장하지 않는 이유\*\***

- 디버깅 : 변이하지 않으면 렌더링 사이에 state가 어떻게 변경되었는지 명확하게 확인할 수 있다.
- **최적화**: 일반적인 React [최적화 전략](https://react-ko.dev/reference/react/memo)은 이전 프로퍼티나 state가 다음 프로퍼티나 state와 동일한 경우 작업을 건너뛰는 것에 의존한다. state를 변이하지 않는다면 변경이 있었는지 확인하는 것이 매우 빠르다. 만약 `prevObj === obj`라면, 내부에 변경된 것이 없다는 것을 확신할 수 있다.
- **새로운 기능**: 우리가 개발 중인 새로운 React 기능은 state가 [스냅샷처럼 취급](https://react-ko.dev/learn/state-as-a-snapshot)되는 것에 의존한다. 과거 버전의 state를 변이하는 경우 새로운 기능을 사용하지 못할 수 있다.
- **요구 사항 변경**: 실행 취소/다시 실행 구현, 변경 내역 표시, 사용자가 양식을 이전 값으로 재설정할 수 있도록 하는 것과 같은 일부 애플리케이션 기능은 아무것도 변이되지 않은 state에서 더 쉽게 수행할 수 있다.
- 실제로는 React에서 state를 변이해서라도 잘 “빠져나갈” 수 있겠지만, state의 불변성을 유지하는 접근 방식을 염두에 두고 개발된 새로운 React 기능을 잘 사용할 수 있기 위해서, 그렇게 하지 말 것을 강력히 권장한다.

## \***\*Updating Arrays in State\*\***

- state에 저장된 배열을 업데이트하려면, 새로운 배열을 만들고(또는 기존 배열을 복사본을 만듦) 새 배열을 사용하도록 state를 설정해야 한다.

### \***\*Updating arrays without mutation\*\***

- React state 내에서 배열을 다룰 때는 왼쪽 열의 메서드를 피하고 대신 오른쪽 열의 메서드를 선호해야 한다.
  <img width="804" alt="image" src="https://user-images.githubusercontent.com/88878874/243516363-6887d056-e947-460b-b606-272441c0308a.png">
  - 또는 두 열의 메서드를 모두 사용할 수 있는 `Immer`을 사용할 수도 있다.
