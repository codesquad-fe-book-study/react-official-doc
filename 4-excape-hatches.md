# Escape Hatches

## Referencing Values with Refs

- 정리 예정

## Manipulating the DOM with Refs

- 정리 예정

## Syncronizing with Effects(Effect와 동기화하기)

- Effects는 렌더링 후 몇몇의 코드를 실행할 수 있게 해주기 때문에 리액트의 바깥에 있는 시스템과 컴포넌트를 동기화시켜줄 수 있다.

### Effect는 무엇인가? 이벤트와는 어떻게 다른가?

리액트 컴포넌트 내부의 2가지 유형의 논리

1. 렌더링 코드: 렌더링 코드는 컴포넌트의 최상위 레벨에 존재한다. 여기서 props와 state를 사용하여 UI를 렌더링한다. 렌더링 코드는 순수해야한다.
2. 이벤트 핸들러: 컴포넌트 내부에 있는 중첩된 함수로, 계산뿐 아니라 별도의 작업도 수행한다. 입력 필드를 업데이트하거나, HTTP POST 요청을 제출하여 제품을 구매하거나 사용자를 다른 화면으로 이동시킬 수 있다.
  - 이벤트 핸들러에는 특정 사용자 인터렉션으로 발생하는 Side Effect(state를 변경하는)가 포함되어있다.

- Effect는 특정 이벤트가 아닌 렌더링 자체로 인해 발생하는 사이드 이펙트를 명시할 수 있다.(어떻게 보면 렌더링 이벤트 리스너라고 할 수 있으려나..?)
- 특정 버튼을 클릭해서 발생하는 건 이벤트이지만, 서버 연결을 설정하는 것은 컴포넌트를 렌더링하는 동안 발생하는 사이드 이펙트이다.
- Effect는 화면 업데이트 후 `커밋`이 끝날 때 실행된다.(커밋이란 렌더링이 완료되고 DOM이 업데이트되는 것을 의미한다.)
- Effect는 언제나 필수가 아니다. React 코드에서 벗어나 일부 외부와 동기화할 때 사용한다는 점을 명심해라!

### Effect 작성 방법

1. Effect 선언
2. Effect의 의존성을 명시
  - 대부분의 Effect는 렌더링할 때마다가 아닌, 필요할 때만 다시 실행해야한다.
  - 의존성을 주는 것은 기존 렌더링 때마다의 실행을 특정 state나 props에만 의존하도록 좁혀 주는 느낌이다!
  - 이 때, 의존성은 useEffect의 콜백 내부에서 사용되는 것만 의존성으로 간주한다.
  - 지정한 모든 의존성의 값이 이전 렌더링 때와 정확히 동일한 경우에만 Effect를 건너뛴다.
    - 이 때, Object.is를 사용하여 비교한다.
3. 필요한 경우 클린업을 추가한다.
   - connect가 있다면 disconnect
   - subscribe가 있다면 unsubscribe
   - fetch가 있다면 cancel 또는 ignore

> useEffect의 의존성으로 ref를 주는 건 문제가 될까?<br/>
> 전혀 문제가 되지 않는다. 그러나 ref는 렌더링때마다 동일한 값을 얻으므로(이것 자체가 ref의 목적이니까) 의존성에 포함시키는 의미가 없다.<br/>
> 단, 부모 컴포넌트에서 `ref`를 전달받는 경우에는 의존성에 해당 props ref를 추가해주는 게 좋다.(부모로부터의 ref가 정말 변하지 않는지 확인해야 하기 때문이다.)

React은 개발 모드에서 strict mode를 적용함으로써 컴포넌트를 두 번씩 렌더링한다. 이 때문에 Effect가 두 번씩 실행되는 것처럼 보일 수 있다.(이는 개발 모드에서만 발생하는 현상이므로, 배포할 때는 이러한 현상이 발생하지 않는다.)

